package yaml

import (
	"fmt"
	"io"
)

const Basename = "action.yml"

func WriteTo(w io.Writer) (i int64, err error) {
	metadata := BuildMetadata()
	var j int
	var k int64

	j, err = fmt.Fprintf(w, `
# Don't edit this file.
# This file is auto-generated by github.com/DeNA/unity-meta-check/tool/action-yaml-gen.

name: %q
author: %q
description: %q

`[1:], metadata.Name, metadata.Author, metadata.Description)
	i += int64(j)
	if err != nil {
		return
	}

	k, err = WriteInputsAsGHActionYAML(w, metadata.Inputs)
	i += k
	if err != nil {
		return
	}

	k, err = WriteRunsAsGHActionYAML(w, metadata.Runs)
	i += k
	if err != nil {
		return
	}

	j, err = fmt.Fprintln(w, "branding:")
	i += int64(j)
	if err != nil {
		return
	}

	j, err = fmt.Fprintf(w, "  icon: %q\n", metadata.BrandingIcon)
	i += int64(j)
	if err != nil {
		return
	}

	j, err = fmt.Fprintf(w, "  color: %q\n", metadata.BrandingColor)
	i += int64(j)
	if err != nil {
		return
	}

	return
}

func WriteInputsAsGHActionYAML(w io.Writer, defs []InputDef) (i int64, err error) {
	var j int
	if len(defs) == 0 {
		j, err = fmt.Fprintln(w, "inputs: []")
		i = int64(j)
		return
	}

	j, err = fmt.Fprintln(w, "inputs:")
	i = int64(j)
	if err != nil {
		return
	}

	for _, def := range defs {
		if def.Required() {
			j, err = fmt.Fprintf(w, `
  %q:
    description: %q
    required: true

`[1:], def.Name(), def.Desc())
		} else {
			j, err = fmt.Fprintf(w, `
  %q:
    description: %q
    required: false
    default: %s

`[1:], def.Name(), def.Desc(), def.DefaultValueAsYAML())
		}

		i += int64(j)
		if err != nil {
			return
		}
	}

	return
}

func WriteRunsAsGHActionYAML(w io.Writer, runs DockerAction) (i int64, err error) {
	var j int

	j, err = fmt.Fprintf(w, `
runs:
  using: "docker"
  image: %q
`[1:], runs.Image)
	i += int64(j)
	if err != nil {
		return
	}

	if len(runs.Env) > 0 {
		j, err = fmt.Fprintln(w, "  env:")
		i += int64(j)
		if err != nil {
			return
		}

		for key, val := range runs.Env {
			j, err = fmt.Fprintf(w, "    %q: %q\n", key, val)
			i += int64(j)
			if err != nil {
				return
			}
		}
	}

	if len(runs.Args) > 0 {
		j, err = fmt.Fprintln(w, "  args:")
		i += int64(j)
		if err != nil {
			return
		}

		for _, arg := range runs.Args {
			j, err = fmt.Fprintf(w, "    - %q\n", arg)
			i += int64(j)
			if err != nil {
				return
			}
		}
	}

	j, err = fmt.Fprint(w, "\n")
	i += int64(j)
	if err != nil {
		return
	}

	return
}
